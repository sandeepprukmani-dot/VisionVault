{"file_contents":{"local_agent.py":{"content":"import asyncio\nimport json\nimport sys\nimport os\nimport base64\nimport uuid\nimport socketio\nfrom playwright.async_api import async_playwright\n\nSERVER_URL = os.environ.get('AGENT_SERVER_URL', 'http://127.0.0.1:6745')\n\nsio = socketio.Client(\n    reconnection=True,\n    reconnection_attempts=5,\n    reconnection_delay=1,\n    reconnection_delay_max=5,\n    logger=False,\n    engineio_logger=False\n)\nagent_id = str(uuid.uuid4())\n\n\n@sio.event\ndef connect():\n    print(f\"Connected to server: {SERVER_URL}\")\n    available_browsers = detect_browsers()\n    sio.emit('agent_register', {\n        'agent_id': agent_id,\n        'browsers': available_browsers\n    })\n\n\n@sio.event\ndef disconnect():\n    print(\"Disconnected from server\")\n\n\n@sio.event\ndef agent_registered(data):\n    print(f\"Agent registered successfully: {data}\")\n\n\n@sio.on('execute_on_agent')\ndef handle_execute(data):\n    test_id = data['test_id']\n    code = data['code']\n    browser = data['browser']\n    mode = data['mode']\n\n    print(f\"\\n{'=' * 50}\")\n    print(f\"Executing test {test_id}\")\n    print(f\"Browser: {browser}, Mode: {mode}\")\n    print(f\"{'=' * 50}\\n\")\n\n    asyncio.run(execute_test(test_id, code, browser, mode))\n\n\ndef detect_browsers():\n    browsers = []\n    try:\n        import subprocess\n\n        if sys.platform == 'win32':\n            chrome_paths = [\n                r\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\",\n                r\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\"\n            ]\n            for path in chrome_paths:\n                if os.path.exists(path):\n                    browsers.append('chromium')\n                    break\n        elif sys.platform == 'darwin':\n            if os.path.exists('/Applications/Google Chrome.app'):\n                browsers.append('chromium')\n            if os.path.exists('/Applications/Firefox.app'):\n                browsers.append('firefox')\n            if os.path.exists('/Applications/Safari.app'):\n                browsers.append('webkit')\n        else:\n            result = subprocess.run(['which', 'google-chrome'], capture_output=True)\n            if result.returncode == 0:\n                browsers.append('chromium')\n            result = subprocess.run(['which', 'firefox'], capture_output=True)\n            if result.returncode == 0:\n                browsers.append('firefox')\n\n        if not browsers:\n            browsers = ['chromium']\n\n    except Exception as e:\n        print(f\"Browser detection error: {e}\")\n        browsers = ['chromium']\n\n    print(f\"Detected browsers: {browsers}\")\n    return browsers\n\n\nasync def execute_test(test_id, code, browser_name, mode):\n    headless = mode == 'headless'\n\n    try:\n        sio.emit('agent_log', {\n            'test_id': test_id,\n            'message': f'Preparing to execute test in {mode} mode...'\n        })\n\n        local_vars = {}\n        exec(code, {}, local_vars)\n\n        if 'run_test' not in local_vars:\n            sio.emit('agent_result', {\n                'test_id': test_id,\n                'success': False,\n                'logs': ['Error: Generated code must contain a run_test function'],\n                'screenshot': None\n            })\n            return\n\n        run_test = local_vars['run_test']\n\n        sio.emit('agent_log', {\n            'test_id': test_id,\n            'message': f'Launching {browser_name} browser...'\n        })\n\n        result = await run_test(browser_name=browser_name, headless=headless)\n\n        screenshot_b64 = None\n        if result.get('screenshot'):\n            screenshot_b64 = base64.b64encode(result['screenshot']).decode('utf-8')\n\n        sio.emit('agent_result', {\n            'test_id': test_id,\n            'success': result.get('success', False),\n            'logs': result.get('logs', []),\n            'screenshot': screenshot_b64\n        })\n\n        print(f\"\\nTest {test_id} completed: {'SUCCESS' if result.get('success') else 'FAILED'}\")\n\n    except Exception as e:\n        print(f\"Execution error: {e}\")\n        sio.emit('agent_result', {\n            'test_id': test_id,\n            'success': False,\n            'logs': [f'Agent execution error: {str(e)}'],\n            'screenshot': None\n        })\n\n\ndef main():\n    print(f\"Starting Browser Automation Agent\")\n    print(f\"Agent ID: {agent_id}\")\n    print(f\"Server URL: {SERVER_URL}\")\n    print(f\"\\nPress Ctrl+C to stop the agent\\n\")\n\n    try:\n        print(\"Connecting to server...\")\n        sio.connect(\n            SERVER_URL,\n            transports=['websocket', 'polling'],\n            wait_timeout=10\n        )\n        print(\"Connection established!\")\n        sio.wait()\n    except KeyboardInterrupt:\n        print(\"\\nShutting down agent...\")\n        sio.disconnect()\n    except Exception as e:\n        print(f\"Error connecting to server: {e}\")\n        print(f\"\\nMake sure:\")\n        print(f\"1. The server is running at {SERVER_URL}\")\n        print(f\"2. You have set the AGENT_SERVER_URL environment variable correctly\")\n        print(f\"3. You have network connectivity\")\n\n\nif __name__ == '__main__':\n    main()\n","size_bytes":5045},"app.py":{"content":"import os\nimport json\nimport sqlite3\nfrom datetime import datetime\nfrom flask import Flask, render_template, request, jsonify, send_from_directory\nfrom flask_socketio import SocketIO, emit\nfrom flask_cors import CORS\nfrom openai import OpenAI\nfrom executor import ServerExecutor\nfrom healing_executor import HealingExecutor\nfrom code_validator import CodeValidator\nimport base64\nimport asyncio\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.environ.get('SESSION_SECRET', 'dev-secret-key')\napp.config['UPLOAD_FOLDER'] = 'uploads'\nCORS(app)\nsocketio = SocketIO(app, cors_allowed_origins=\"*\")\n\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\nos.makedirs(os.path.join(app.config['UPLOAD_FOLDER'], 'screenshots'), exist_ok=True)\nos.makedirs(os.path.join(app.config['UPLOAD_FOLDER'], 'logs'), exist_ok=True)\n\nopenai_api_key = os.environ.get('OPENAI_API_KEY')\nclient = OpenAI(api_key=openai_api_key) if openai_api_key else None\n\nconnected_agents = {}\n\ndef init_db():\n    conn = sqlite3.connect('automation.db')\n    c = conn.cursor()\n    c.execute('''CREATE TABLE IF NOT EXISTS test_history\n                 (id INTEGER PRIMARY KEY AUTOINCREMENT,\n                  command TEXT NOT NULL,\n                  generated_code TEXT NOT NULL,\n                  healed_code TEXT,\n                  browser TEXT,\n                  mode TEXT,\n                  execution_location TEXT,\n                  status TEXT,\n                  logs TEXT,\n                  screenshot_path TEXT,\n                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')\n    conn.commit()\n    conn.close()\n\ninit_db()\n\ndef generate_playwright_code(natural_language_command, browser='chromium'):\n    if not client:\n        raise Exception(\"OpenAI API key not configured. Please set the OPENAI_API_KEY environment variable.\")\n    try:\n        response = client.chat.completions.create(\n            model=\"gpt-4o-mini\",\n            messages=[\n                {\"role\": \"system\", \"content\": \"\"\"You are an expert at converting natural language commands into Playwright Python code.\nGenerate complete, executable Playwright code that:\n1. Uses async/await syntax\n2. Includes proper browser launch with the specified browser\n3. Has error handling\n4. Returns a dict with 'success', 'logs', and 'screenshot' keys\n5. Takes screenshot on success or error\n6. The code should be a complete async function named 'run_test' that takes browser_name and headless parameters\n\nExample structure:\nasync def run_test(browser_name='chromium', headless=True):\n    from playwright.async_api import async_playwright\n    logs = []\n    screenshot = None\n    try:\n        async with async_playwright() as p:\n            browser = await getattr(p, browser_name).launch(headless=headless)\n            page = await browser.new_page()\n            # Your automation code here\n            logs.append(\"Step completed\")\n            screenshot = await page.screenshot()\n            await browser.close()\n            return {'success': True, 'logs': logs, 'screenshot': screenshot}\n    except Exception as e:\n        logs.append(f\"Error: {str(e)}\")\n        return {'success': False, 'logs': logs, 'screenshot': screenshot}\n\nOnly return the function code, no explanations.\"\"\"},\n                {\"role\": \"user\", \"content\": f\"Convert this to Playwright code for {browser}: {natural_language_command}\"}\n            ],\n            temperature=0.3\n        )\n        \n        code = response.choices[0].message.content.strip()\n        if code.startswith('```python'):\n            code = code[9:]\n        if code.startswith('```'):\n            code = code[3:]\n        if code.endswith('```'):\n            code = code[:-3]\n        \n        return code.strip()\n    except Exception as e:\n        raise Exception(f\"OpenAI API error: {str(e)}\")\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/api/history')\ndef get_history():\n    conn = sqlite3.connect('automation.db')\n    c = conn.cursor()\n    c.execute('SELECT * FROM test_history ORDER BY created_at DESC LIMIT 50')\n    rows = c.fetchall()\n    conn.close()\n    \n    history = []\n    for row in rows:\n        history.append({\n            'id': row[0],\n            'command': row[1],\n            'generated_code': row[2],\n            'browser': row[3],\n            'mode': row[4],\n            'execution_location': row[5],\n            'status': row[6],\n            'logs': row[7],\n            'screenshot_path': row[8],\n            'created_at': row[9]\n        })\n    \n    return jsonify(history)\n\n@app.route('/api/execute', methods=['POST'])\ndef execute_test():\n    data = request.json\n    command = data.get('command')\n    browser = data.get('browser', 'chromium')\n    mode = data.get('mode', 'headless')\n    execution_location = data.get('execution_location', 'server')\n    use_healing = data.get('use_healing', True)\n    \n    if not command:\n        return jsonify({'error': 'Command is required'}), 400\n    \n    try:\n        generated_code = generate_playwright_code(command, browser)\n        \n        validator = CodeValidator()\n        if not validator.validate(generated_code):\n            error_msg = \"Generated code failed security validation: \" + \"; \".join(validator.get_errors())\n            return jsonify({'error': error_msg}), 400\n        \n        conn = sqlite3.connect('automation.db')\n        c = conn.cursor()\n        c.execute('INSERT INTO test_history (command, generated_code, browser, mode, execution_location, status) VALUES (?, ?, ?, ?, ?, ?)',\n                  (command, generated_code, browser, mode, execution_location, 'pending'))\n        test_id = c.lastrowid\n        conn.commit()\n        conn.close()\n        \n        if execution_location == 'server':\n            if use_healing:\n                socketio.start_background_task(execute_with_healing, test_id, generated_code, browser, mode)\n            else:\n                socketio.start_background_task(execute_on_server, test_id, generated_code, browser, mode)\n        else:\n            socketio.emit('execute_on_agent', {\n                'test_id': test_id,\n                'code': generated_code,\n                'browser': browser,\n                'mode': mode\n            })\n        \n        return jsonify({'test_id': test_id, 'code': generated_code})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\ndef execute_on_server(test_id, code, browser, mode):\n    executor = ServerExecutor()\n    headless = mode == 'headless'\n    \n    socketio.emit('execution_status', {\n        'test_id': test_id,\n        'status': 'running',\n        'message': f'Executing on server in {mode} mode...'\n    })\n    \n    result = executor.execute(code, browser, headless)\n    \n    screenshot_path = None\n    if result.get('screenshot'):\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(result['screenshot'])\n    \n    logs_json = json.dumps(result.get('logs', []))\n    status = 'success' if result.get('success') else 'failed'\n    \n    conn = sqlite3.connect('automation.db')\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=? WHERE id=?',\n              (status, logs_json, screenshot_path, test_id))\n    conn.commit()\n    conn.close()\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': result.get('logs', []),\n        'screenshot_path': screenshot_path\n    })\n\ndef execute_with_healing(test_id, code, browser, mode):\n    healing_executor = HealingExecutor(socketio)\n    headless = mode == 'headless'\n    \n    socketio.emit('execution_status', {\n        'test_id': test_id,\n        'status': 'running',\n        'message': f'Executing with healing in {mode} mode...'\n    })\n    \n    result = asyncio.run(healing_executor.execute_with_healing(code, browser, headless, test_id))\n    \n    screenshot_path = None\n    if result.get('screenshot'):\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(result['screenshot'])\n    \n    logs_json = json.dumps(result.get('logs', []))\n    status = 'success' if result.get('success') else 'failed'\n    healed_code = result.get('healed_script')\n    \n    conn = sqlite3.connect('automation.db')\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=?, healed_code=? WHERE id=?',\n              (status, logs_json, screenshot_path, healed_code, test_id))\n    conn.commit()\n    conn.close()\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': result.get('logs', []),\n        'screenshot_path': screenshot_path,\n        'healed_script': healed_code,\n        'failed_locators': result.get('failed_locators', [])\n    })\n\n@app.route('/api/heal', methods=['POST'])\ndef heal_locator():\n    data = request.json\n    test_id = data.get('test_id')\n    failed_locator = data.get('failed_locator')\n    healed_locator = data.get('healed_locator')\n    \n    if not all([test_id, failed_locator, healed_locator]):\n        return jsonify({'error': 'Missing required fields'}), 400\n    \n    try:\n        conn = sqlite3.connect('automation.db')\n        c = conn.cursor()\n        c.execute('SELECT generated_code, healed_code FROM test_history WHERE id=?', (test_id,))\n        row = c.fetchone()\n        \n        if not row:\n            return jsonify({'error': 'Test not found'}), 404\n        \n        original_code = row[0]\n        current_healed = row[1] or original_code\n        \n        new_healed = current_healed.replace(failed_locator, healed_locator)\n        \n        c.execute('UPDATE test_history SET healed_code=? WHERE id=?', (new_healed, test_id))\n        conn.commit()\n        conn.close()\n        \n        socketio.emit('script_healed', {\n            'test_id': test_id,\n            'healed_script': new_healed,\n            'failed_locator': failed_locator,\n            'healed_locator': healed_locator\n        })\n        \n        return jsonify({'success': True, 'healed_script': new_healed})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/uploads/<path:filename>')\ndef uploaded_file(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n\n@app.route('/api/agent/download')\ndef download_agent():\n    return send_from_directory('.', 'local_agent.py', as_attachment=True)\n\n@socketio.on('connect')\ndef handle_connect():\n    print(f'Client connected: {request.sid}')\n    emit('connected', {'sid': request.sid})\n\n@socketio.on('disconnect')\ndef handle_disconnect():\n    print(f'Client disconnected: {request.sid}')\n    if request.sid in connected_agents:\n        del connected_agents[request.sid]\n        print(f'Updated connected_agents after disconnect: {connected_agents}')\n        socketio.emit('agents_update', {'agents': list(connected_agents.values())})\n\n@socketio.on('agent_register')\ndef handle_agent_register(data):\n    agent_id = data.get('agent_id')\n    connected_agents[request.sid] = {\n        'agent_id': agent_id,\n        'browsers': data.get('browsers', []),\n        'connected_at': datetime.now().isoformat()\n    }\n    print(f'Agent registered: {agent_id}')\n    print(f'Updated connected_agents after register: {connected_agents}')\n    emit('agent_registered', {'status': 'success'})\n    print(f'Emitting agents_update: {list(connected_agents.values())}')\n    socketio.emit('agents_update', {'agents': list(connected_agents.values())})\n\n@socketio.on('agent_result')\ndef handle_agent_result(data):\n    test_id = data.get('test_id')\n    success = data.get('success')\n    logs = data.get('logs', [])\n    screenshot_data = data.get('screenshot')\n    \n    screenshot_path = None\n    if screenshot_data:\n        screenshot_path = f\"screenshots/test_{test_id}.png\"\n        screenshot_bytes = base64.b64decode(screenshot_data)\n        with open(os.path.join(app.config['UPLOAD_FOLDER'], screenshot_path), 'wb') as f:\n            f.write(screenshot_bytes)\n    \n    logs_json = json.dumps(logs)\n    status = 'success' if success else 'failed'\n    \n    conn = sqlite3.connect('automation.db')\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET status=?, logs=?, screenshot_path=? WHERE id=?',\n              (status, logs_json, screenshot_path, test_id))\n    conn.commit()\n    conn.close()\n    \n    socketio.emit('execution_complete', {\n        'test_id': test_id,\n        'status': status,\n        'logs': logs,\n        'screenshot_path': screenshot_path\n    })\n\n@socketio.on('agent_log')\ndef handle_agent_log(data):\n    socketio.emit('execution_status', {\n        'test_id': data.get('test_id'),\n        'status': 'running',\n        'message': data.get('message')\n    })\n\n@socketio.on('element_selected')\ndef handle_element_selected(data):\n    test_id = data.get('test_id')\n    selector = data.get('selector')\n    failed_locator = data.get('failed_locator')\n    \n    healing_executor = HealingExecutor(socketio)\n    healed_script = healing_executor.heal_script(\n        data.get('original_code', ''),\n        failed_locator,\n        selector\n    )\n    \n    conn = sqlite3.connect('automation.db')\n    c = conn.cursor()\n    c.execute('UPDATE test_history SET healed_code=? WHERE id=?', (healed_script, test_id))\n    conn.commit()\n    conn.close()\n    \n    socketio.emit('script_healed', {\n        'test_id': test_id,\n        'healed_script': healed_script\n    })\n\nif __name__ == '__main__':\n    port = int(os.environ.get('PORT', 5000))\n    socketio.run(app, host='0.0.0.0', port=port, debug=True, allow_unsafe_werkzeug=True)\n","size_bytes":13698},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"VisionVault - AI-Powered Browser Automation\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"eventlet>=0.37.0\",\n    \"flask>=3.1.2\",\n    \"flask-cors>=6.0.1\",\n    \"flask-socketio>=5.5.1\",\n    \"gunicorn>=23.0.0\",\n    \"openai>=2.1.0\",\n    \"pillow>=11.3.0\",\n    \"playwright>=1.55.0\",\n    \"python-socketio>=5.14.1\",\n    \"websocket-client>=1.8.0\",\n]\n","size_bytes":415},"executor.py":{"content":"import asyncio\nimport sys\nfrom io import StringIO\nfrom code_validator import CodeValidator\n\nclass ServerExecutor:\n    def execute(self, code, browser_name='chromium', headless=True):\n        try:\n            validator = CodeValidator()\n            if not validator.validate(code):\n                return {\n                    'success': False,\n                    'logs': ['Security validation failed: ' + '; '.join(validator.get_errors())],\n                    'screenshot': None\n                }\n            \n            restricted_globals = {\n                '__builtins__': {\n                    'True': True,\n                    'False': False,\n                    'None': None,\n                    'dict': dict,\n                    'list': list,\n                    'str': str,\n                    'int': int,\n                    'float': float,\n                    'bool': bool,\n                    'len': len,\n                    'range': range,\n                    'enumerate': enumerate,\n                    'zip': zip,\n                    'Exception': Exception,\n                    'ValueError': ValueError,\n                    'TypeError': TypeError,\n                    'KeyError': KeyError,\n                    'AttributeError': AttributeError,\n                    'getattr': getattr,\n                    'setattr': setattr,\n                    'hasattr': hasattr,\n                    'print': print,\n                    '__import__': __import__,\n\n                }\n            }\n            \n            local_vars = {}\n            exec(code, restricted_globals, local_vars)\n            \n            if 'run_test' not in local_vars:\n                return {\n                    'success': False,\n                    'logs': ['Error: Generated code must contain a run_test function'],\n                    'screenshot': None\n                }\n            \n            run_test = local_vars['run_test']\n            \n            result = asyncio.run(run_test(browser_name=browser_name, headless=headless))\n            \n            return result\n        except Exception as e:\n            return {\n                'success': False,\n                'logs': [f'Execution error: {str(e)}'],\n                'screenshot': None\n            }\n","size_bytes":2249},"agent.py":{"content":"# agent.py\nimport asyncio\nimport json\nimport sys\nimport os\nimport base64\nimport uuid\nimport socketio\nfrom playwright.async_api import async_playwright\n\nSERVER_URL = os.environ.get('AGENT_SERVER_URL', 'http://127.0.0.1:5000')\n\nsio = socketio.Client(\n    reconnection=True,\n    reconnection_attempts=5,\n    reconnection_delay=1,\n    reconnection_delay_max=5,\n    logger=False,\n    engineio_logger=False\n)\nagent_id = str(uuid.uuid4())\n\n\n@sio.event\ndef connect():\n    print(f\"Connected to server: {SERVER_URL}\")\n    available_browsers = [\"chromium\", \"firefox\", \"webkit\"]\n    sio.emit('agent_register', {\n        'agent_id': agent_id,\n        'browsers': available_browsers\n    })\n\n\n@sio.event\ndef disconnect():\n    print(\"Disconnected from server\")\n\n\n@sio.event\ndef agent_registered(data):\n    print(f\"Agent registered successfully: {data}\")\n\n\n@sio.on('execute_on_agent')\ndef handle_execute(data):\n    test_id = data['test_id']\n    code = data['code']\n    browser = data['browser']\n    mode = data['mode']\n\n    print(f\"\\n{'=' * 50}\")\n    print(f\"Executing test {test_id}\")\n    print(f\"Browser: {browser}, Mode: {mode}\")\n    print(f\"{'=' * 50}\\n\")\n\n    asyncio.run(execute_test(test_id, code, browser, mode))\n\n\nasync def execute_test(test_id, code, browser_name, mode):\n    headless = mode == 'headless'\n\n    try:\n        sio.emit('agent_log', {\n            'test_id': test_id,\n            'message': f'Preparing to execute test in {mode} mode...'\n        })\n\n        local_vars = {}\n        exec(code, {}, local_vars)\n\n        if 'run_test' not in local_vars:\n            sio.emit('agent_result', {\n                'test_id': test_id,\n                'success': False,\n                'logs': ['Error: Generated code must contain a run_test function'],\n                'screenshot': None\n            })\n            return\n\n        run_test = local_vars['run_test']\n\n        sio.emit('agent_log', {\n            'test_id': test_id,\n            'message': f'Launching {browser_name} browser...'\n        })\n\n        result = await run_test(browser_name=browser_name, headless=headless)\n\n        screenshot_b64 = None\n        if result.get('screenshot'):\n            screenshot_b64 = base64.b64encode(result['screenshot']).decode('utf-8')\n\n        sio.emit('agent_result', {\n            'test_id': test_id,\n            'success': result.get('success', False),\n            'logs': result.get('logs', []),\n            'screenshot': screenshot_b64\n        })\n\n        print(f\"\\nTest {test_id} completed: {'SUCCESS' if result.get('success') else 'FAILED'}\")\n\n    except Exception as e:\n        print(f\"Execution error: {e}\")\n        sio.emit('agent_result', {\n            'test_id': test_id,\n            'success': False,\n            'logs': [f'Agent execution error: {str(e)}'],\n            'screenshot': None\n        })\n\n\ndef main():\n    print(f\"Starting Browser Automation Agent\")\n    print(f\"Agent ID: {agent_id}\")\n    print(f\"Server URL: {SERVER_URL}\")\n    print(f\"\\nPress Ctrl+C to stop the agent\\n\")\n\n    while True:\n        try:\n            print(\"Connecting to server...\")\n            sio.connect(\n                SERVER_URL,\n                transports=['websocket', 'polling'],\n                wait_timeout=10\n            )\n            print(\"Connection established!\")\n            sio.wait()\n        except KeyboardInterrupt:\n            print(\"\\nShutting down agent...\")\n            sio.disconnect()\n            break\n        except Exception as e:\n            print(f\"Error connecting to server: {e}\")\n            print(\"Retrying connection in 5 seconds...\")\n            import time\n            time.sleep(5)\n\n\nif __name__ == '__main__':\n    main()\n","size_bytes":3648},"healing_executor.py":{"content":"import asyncio\nimport json\nimport re\nfrom code_validator import CodeValidator\nfrom openai import OpenAI\nimport os\n\nclass HealingExecutor:\n    def __init__(self, socketio):\n        self.socketio = socketio\n        self.client = OpenAI(api_key=os.environ.get('OPENAI_API_KEY'))\n        self.healed_script = None\n        self.failed_locators = []\n        self.retry_count = 0\n        self.max_retries = 3\n        \n    def improve_locator_with_ai(self, failed_locator, error_message, page_html_snippet=''):\n        \"\"\"Use AI to suggest better locator strategies.\"\"\"\n        try:\n            response = self.client.chat.completions.create(\n                model=\"gpt-4o-mini\",\n                messages=[\n                    {\"role\": \"system\", \"content\": \"\"\"You are an expert at web automation and CSS/XPath selectors.\nWhen a locator fails, suggest better, more robust alternatives. Consider:\n1. Using text content locators when possible\n2. Using data-testid or aria-labels\n3. Using role-based selectors\n4. Creating more specific CSS selectors\n5. Using XPath as last resort\n\nReturn ONLY the improved locator string, nothing else.\"\"\"},\n                    {\"role\": \"user\", \"content\": f\"\"\"Failed locator: {failed_locator}\nError: {error_message}\nPage context: {page_html_snippet[:500] if page_html_snippet else 'Not available'}\n\nSuggest a better locator:\"\"\"}\n                ],\n                temperature=0.3\n            )\n            \n            improved = response.choices[0].message.content.strip()\n            if improved.startswith('```'):\n                improved = improved.split('\\n')[1]\n            if improved.endswith('```'):\n                improved = improved.rsplit('\\n', 1)[0]\n                \n            return improved.strip('\"\\'')\n        except Exception as e:\n            print(f\"AI locator improvement error: {e}\")\n            return failed_locator\n    \n    def heal_script(self, original_code, failed_locator, healed_locator):\n        \"\"\"Replace failed locator with healed one in the script.\"\"\"\n        healed = original_code.replace(failed_locator, healed_locator)\n        self.healed_script = healed\n        return healed\n    \n    async def execute_with_healing(self, code, browser_name, headless, test_id):\n        \"\"\"Execute code with automatic healing and retry on failures.\"\"\"\n        validator = CodeValidator()\n        if not validator.validate(code):\n            return {\n                'success': False,\n                'logs': ['Security validation failed: ' + '; '.join(validator.get_errors())],\n                'screenshot': None,\n                'healed_script': None\n            }\n        \n        self.healed_script = code\n        current_code = code\n        \n        for attempt in range(self.max_retries):\n            result = await self._execute_single_attempt(current_code, browser_name, headless, test_id, attempt)\n            \n            if result['success']:\n                return {\n                    'success': True,\n                    'logs': result['logs'],\n                    'screenshot': result['screenshot'],\n                    'healed_script': self.healed_script if self.healed_script != code else None,\n                    'failed_locators': self.failed_locators\n                }\n            \n            if not result.get('can_heal'):\n                return result\n            \n            failed_locator = result.get('failed_locator')\n            if failed_locator:\n                self.socketio.emit('healing_required', {\n                    'test_id': test_id,\n                    'failed_locator': failed_locator,\n                    'error': result.get('error_message', ''),\n                    'attempt': attempt + 1,\n                    'headless': headless\n                })\n                \n                improved_locator = self.improve_locator_with_ai(\n                    failed_locator, \n                    result.get('error_message', ''),\n                    result.get('page_content', '')\n                )\n                \n                result['logs'].append(f\"🔧 Healing attempt {attempt + 1}: AI suggested locator: {improved_locator}\")\n                \n                current_code = self.heal_script(current_code, failed_locator, improved_locator)\n                \n                self.socketio.emit('script_healed', {\n                    'test_id': test_id,\n                    'healed_script': current_code,\n                    'failed_locator': failed_locator,\n                    'healed_locator': improved_locator,\n                    'attempt': attempt + 1\n                })\n                \n                await asyncio.sleep(1)\n            else:\n                return result\n        \n        return {\n            'success': False,\n            'logs': result['logs'] + [f'❌ Failed after {self.max_retries} healing attempts'],\n            'screenshot': result.get('screenshot'),\n            'healed_script': self.healed_script,\n            'failed_locators': self.failed_locators\n        }\n    \n    async def _execute_single_attempt(self, code, browser_name, headless, test_id, attempt_num):\n        \"\"\"Execute a single attempt of the automation code.\"\"\"\n        logs = [f\"▶️  Attempt {attempt_num + 1}: Executing automation...\"]\n        screenshot = None\n        page_content = ''\n        \n        try:\n            from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeout\n            \n            async with async_playwright() as p:\n                browser = await getattr(p, browser_name).launch(headless=headless)\n                page = await browser.new_page()\n                \n                restricted_globals = {\n                    '__builtins__': {\n                        'True': True, 'False': False, 'None': None,\n                        'dict': dict, 'list': list, 'str': str, 'int': int,\n                        'float': float, 'bool': bool, 'len': len,\n                        'Exception': Exception, '__import__': __import__,\n                    }\n                }\n                \n                local_vars = {}\n                \n                try:\n                    exec(code, restricted_globals, local_vars)\n                    \n                    if 'run_test' in local_vars:\n                        result = await local_vars['run_test'](browser_name=browser_name, headless=headless)\n                        logs.extend(result.get('logs', []))\n                        screenshot = result.get('screenshot')\n                        logs.append(\"✅ Execution completed successfully\")\n                    else:\n                        logs.append(\"✅ Code executed successfully\")\n                        screenshot = await page.screenshot()\n                        \n                except PlaywrightTimeout as e:\n                    error_msg = str(e)\n                    logs.append(f\"⏱️  Timeout error: {error_msg}\")\n                    \n                    failed_locator = self.extract_failed_locator(error_msg)\n                    \n                    try:\n                        page_content = await page.content()\n                        screenshot = await page.screenshot()\n                    except:\n                        pass\n                    \n                    await browser.close()\n                    \n                    if failed_locator:\n                        self.failed_locators.append({\n                            'locator': failed_locator,\n                            'error': error_msg,\n                            'attempt': attempt_num + 1\n                        })\n                        \n                        return {\n                            'success': False,\n                            'logs': logs,\n                            'screenshot': screenshot,\n                            'can_heal': True,\n                            'failed_locator': failed_locator,\n                            'error_message': error_msg,\n                            'page_content': page_content\n                        }\n                    else:\n                        return {\n                            'success': False,\n                            'logs': logs,\n                            'screenshot': screenshot,\n                            'can_heal': False\n                        }\n                \n                except Exception as e:\n                    error_msg = str(e)\n                    logs.append(f\"❌ Execution error: {error_msg}\")\n                    \n                    failed_locator = self.extract_failed_locator(error_msg)\n                    \n                    try:\n                        page_content = await page.content()\n                        screenshot = await page.screenshot()\n                    except:\n                        pass\n                    \n                    await browser.close()\n                    \n                    if failed_locator:\n                        self.failed_locators.append({\n                            'locator': failed_locator,\n                            'error': error_msg,\n                            'attempt': attempt_num + 1\n                        })\n                        \n                        return {\n                            'success': False,\n                            'logs': logs,\n                            'screenshot': screenshot,\n                            'can_heal': True,\n                            'failed_locator': failed_locator,\n                            'error_message': error_msg,\n                            'page_content': page_content\n                        }\n                    else:\n                        return {\n                            'success': False,\n                            'logs': logs,\n                            'screenshot': screenshot,\n                            'can_heal': False\n                        }\n                \n                await browser.close()\n                \n            return {\n                'success': True,\n                'logs': logs,\n                'screenshot': screenshot\n            }\n            \n        except Exception as e:\n            logs.append(f'💥 Fatal error: {str(e)}')\n            return {\n                'success': False,\n                'logs': logs,\n                'screenshot': screenshot,\n                'can_heal': False\n            }\n    \n    def extract_failed_locator(self, error_message):\n        \"\"\"Extract the failed locator from error message.\"\"\"\n        patterns = [\n            r'locator\\(\"([^\"]+)\"\\)',\n            r'selector \"([^\"]+)\"',\n            r'element \"([^\"]+)\"',\n            r'get_by_text\\(\"([^\"]+)\"\\)',\n            r'get_by_role\\(\"([^\"]+)\"\\)',\n            r\"locator\\('([^']+)'\\)\",\n            r\"selector '([^']+)'\",\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, error_message, re.IGNORECASE)\n            if match:\n                return match.group(1)\n        \n        return None\n","size_bytes":10940},"code_validator.py":{"content":"import ast\nimport re\n\nclass CodeValidator:\n    ALLOWED_IMPORTS = {\n        'playwright.async_api',\n        'asyncio',\n        'time',\n        'datetime',\n        're',\n        'json',\n        'base64'\n    }\n    \n    DANGEROUS_MODULES = {\n        'os', 'sys', 'subprocess', 'shutil', 'eval', 'exec',\n        'compile', '__import__', 'open', 'file', 'input',\n        'execfile', 'reload', 'importlib', 'pickle', 'shelve',\n        'socket', 'urllib', 'requests', 'http', 'ftplib',\n        'telnetlib', 'smtplib', 'poplib', 'imaplib'\n    }\n    \n    def __init__(self):\n        self.errors = []\n    \n    def validate(self, code):\n        self.errors = []\n        \n        if not code or not isinstance(code, str):\n            self.errors.append(\"Code must be a non-empty string\")\n            return False\n        \n        if not self._check_function_structure(code):\n            return False\n        \n        if not self._check_dangerous_imports(code):\n            return False\n        \n        if not self._check_dangerous_patterns(code):\n            return False\n        \n        try:\n            tree = ast.parse(code)\n            if not self._validate_ast(tree):\n                return False\n        except SyntaxError as e:\n            self.errors.append(f\"Syntax error: {str(e)}\")\n            return False\n        \n        return True\n    \n    def _check_function_structure(self, code):\n        if 'async def run_test' not in code:\n            self.errors.append(\"Code must contain 'async def run_test' function\")\n            return False\n        \n        if 'playwright.async_api import async_playwright' not in code:\n            self.errors.append(\"Code must use 'from playwright.async_api import async_playwright'\")\n            return False\n        \n        return True\n    \n    def _check_dangerous_imports(self, code):\n        for module in self.DANGEROUS_MODULES:\n            patterns = [\n                f'import {module}',\n                f'from {module}',\n                f'__import__(\"{module}\")',\n                f\"__import__('{module}')\"\n            ]\n            for pattern in patterns:\n                if pattern in code:\n                    self.errors.append(f\"Dangerous import detected: {module}\")\n                    return False\n        \n        return True\n    \n    def _check_dangerous_patterns(self, code):\n        dangerous_patterns = [\n            (r'\\beval\\s*\\(', 'eval() function'),\n            (r'\\bexec\\s*\\(', 'exec() function'),\n            (r'\\b__import__\\s*\\(', '__import__() function'),\n            (r'\\bcompile\\s*\\(', 'compile() function'),\n            (r'\\bopen\\s*\\(', 'open() function (file access)'),\n            (r'\\.system\\s*\\(', 'system() call'),\n            (r'\\.popen\\s*\\(', 'popen() call'),\n            (r'\\.spawn\\s*\\(', 'spawn() call'),\n        ]\n        \n        for pattern, name in dangerous_patterns:\n            if re.search(pattern, code, re.IGNORECASE):\n                self.errors.append(f\"Dangerous pattern detected: {name}\")\n                return False\n        \n        return True\n    \n    def _validate_ast(self, tree):\n        for node in ast.walk(tree):\n            if isinstance(node, ast.Import):\n                for alias in node.names:\n                    if not self._is_allowed_import(alias.name):\n                        self.errors.append(f\"Disallowed import: {alias.name}\")\n                        return False\n            \n            elif isinstance(node, ast.ImportFrom):\n                if node.module and not self._is_allowed_import(node.module):\n                    self.errors.append(f\"Disallowed import from: {node.module}\")\n                    return False\n            \n            elif isinstance(node, ast.Call):\n                if isinstance(node.func, ast.Name):\n                    if node.func.id in ['eval', 'exec', 'compile', '__import__', 'open']:\n                        self.errors.append(f\"Dangerous function call: {node.func.id}\")\n                        return False\n        \n        return True\n    \n    def _is_allowed_import(self, module_name):\n        for allowed in self.ALLOWED_IMPORTS:\n            if module_name.startswith(allowed):\n                return True\n        return False\n    \n    def get_errors(self):\n        return self.errors\n","size_bytes":4240},"replit.md":{"content":"# VisionVault - AI-Powered Browser Automation\n\n## Overview\nVisionVault is a sophisticated browser automation platform that converts natural language commands into executable Playwright scripts using OpenAI's GPT models. The application provides a beautiful web interface for creating, executing, and managing browser automation tasks.\n\n## Project Architecture\n\n### Backend (Python/Flask)\n- **Framework**: Flask with Flask-SocketIO for real-time communication\n- **AI Integration**: OpenAI GPT-4o-mini for code generation\n- **Browser Automation**: Playwright for Python\n- **Database**: SQLite for test history and logs\n- **Security**: Code validation to prevent malicious code execution\n\n### Frontend\n- **UI**: Custom dark-themed interface with real-time updates\n- **Communication**: Socket.IO for bi-directional event-based communication\n- **Features**:\n  - Natural language automation input\n  - Headless/Headful mode selection\n  - Real-time execution logs\n  - Screenshot capture\n  - Test history tracking\n\n### Key Components\n\n1. **app.py** - Main Flask application with API endpoints and SocketIO handlers\n2. **executor.py** - Server-side Playwright code executor with security sandboxing\n3. **code_validator.py** - Security validation for generated code\n4. **local_agent.py** - Optional local agent for running tests on user's machine\n5. **templates/index.html** - Main web interface\n\n## Features\n\n- ✅ Natural language to Playwright code conversion\n- ✅ Real-time execution with live logs\n- ✅ Screenshot capture on success/failure\n- ✅ Test history and management\n- ✅ Secure code execution with validation\n- ✅ Server-side and local agent execution modes\n- ✅ Multiple browser support (Chromium, Firefox, WebKit)\n\n## Setup Requirements\n\n### Environment Variables\n- **OPENAI_API_KEY**: Required for AI code generation (not set - needs to be configured)\n- **PORT**: Server port (default: 5000)\n- **SESSION_SECRET**: Flask session secret (auto-generated if not set)\n\n### Python Dependencies\n- flask\n- flask-socketio\n- flask-cors\n- openai\n- playwright\n- python-socketio\n- websocket-client\n- eventlet\n- gunicorn\n\n## Current Configuration\n\n### Server\n- **Host**: 0.0.0.0\n- **Port**: 5000\n- **Mode**: Development with debug enabled\n- **CORS**: Enabled for all origins\n\n### Playwright\n- **Installed Browsers**: Chromium (headless shell)\n- **Execution Mode**: Server-side (headless by default)\n- **Screenshot**: Enabled for all executions\n\n## Usage\n\n1. **Web Interface**: Access the app through the Replit preview\n2. **Natural Language Input**: Describe automation tasks like:\n   - \"Navigate to Amazon and search for wireless headphones\"\n   - \"Go to LinkedIn and extract all job postings for Software Engineer\"\n   - \"Check my Gmail inbox for invoices and download them\"\n\n3. **Execution Modes**:\n   - **Server**: Runs on Replit server (headless only due to no display)\n   - **Local Agent**: Download agent to run on your local machine (supports headful mode)\n\n## Database Schema\n\n### test_history table\n- id (PRIMARY KEY)\n- command (TEXT) - Natural language command\n- generated_code (TEXT) - Generated Playwright code\n- browser (TEXT) - Browser type\n- mode (TEXT) - Execution mode (headless/headful)\n- execution_location (TEXT) - server/agent\n- status (TEXT) - pending/success/failed\n- logs (TEXT) - JSON array of execution logs\n- screenshot_path (TEXT) - Path to screenshot\n- created_at (TIMESTAMP)\n\n## Recent Changes\n- **2025-10-10**: Initial import and setup completed\n  - Imported from GitHub repository (master branch)\n  - Configured for Replit environment\n  - Fixed Python package dependencies (python-socketio)\n  - Installed Playwright browsers\n  - Configured server for port 5000 with 0.0.0.0 binding\n  - Removed hardcoded API keys for security\n\n## Next Steps\n1. Set up OpenAI API key via environment variables\n2. Configure deployment for production\n3. Test browser automation with sample commands\n4. Consider adding authentication for multi-user support\n","size_bytes":3964},"main.py":{"content":"from app import app, socketio\n\nif __name__ == '__main__':\n    import os\n    port = int(os.environ.get('PORT', 5000))\n    socketio.run(app, host='0.0.0.0', port=port, debug=True, allow_unsafe_werkzeug=True)\n","size_bytes":206}},"version":2}